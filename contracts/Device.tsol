pragma ever-solidity ^0.70.0;

pragma AbiHeader expire;

import {Errors} from "./libraries/Errors.tsol";
import {INode} from "./interfaces/INode.tsol";
import {IUpgradable} from "./interfaces/IUpgradable.tsol";

contract Device is IUpgradable {
    uint32 contractVersion_; // contract version

    string[] public owners_; // public keys of device owners
    string public dtype_; // device type 
    string public version_; // firmware version

    address public node_; // current node address
    uint32 public lastRegisterTime_; // last registration timestamp

    address public elector_; // elector contract address

    address public vendor_; // vendor contract address
    string public vendorName_; // readable name of vendor
    string public vendorData_; // vendor data

    bool public active_; // device active / inactive for iot4b services
    bool public lock_; // device lock / unlock for management
    bool public stat_; // enable / disable collecting stat

    //events
    
    // Event that is emitted when node address is changed
    event NodeChange(address indexed contractAddress, address oldNode, address newNode);

    // Event that is emitted when some device data was changed
    event DeviceUpdate(address indexed contractAddress, address newNode);


    // Modifier that allows public function to accept all external calls.
    modifier alwaysAccept {
        tvm.accept();
        _;
    }

    modifier onlyDevice() {
        require(msg.pubkey() == tvm.pubkey(), Errors.NOT_ALLOWED);
        tvm.accept();
        _;
    }

    modifier onlyOwner() {
        require(msg.pubkey() == tvm.pubkey(), Errors.NOT_ALLOWED);

        //TODO надо проверять что вызывающий метод контракт в списке владельцев
        //require(msg.pubkey() == tvm.pubkey() || isOwnerExists(msg.pubkey()), Errors.NOT_ALLOWED);
        tvm.accept();
        _;
    }

    modifier onlyElectorContract() {
        require(msg.sender == elector_, Errors.NOT_ALLOWED);
        tvm.accept();
        _;
    }

    modifier onlyNodeContract() {
        require(msg.sender == node_, Errors.NOT_ALLOWED);
        tvm.accept();
        _;
    }

    modifier onlyVendorContract() {
        require(msg.sender == vendor_, Errors.NOT_ALLOWED);
        tvm.accept();
        _;
    }

    constructor(
        address elector,
        address vendor,
        string[] owners,
        string dtype,
        string version,
        string vendorName,
        string vendorData
    ) {
        tvm.accept();
        // setup addresses data
        elector_ = elector;
        vendor_ = vendor;
        owners_ = owners;
        active_ = false;
        lock_ = false;
        stat_ = false;
        dtype_ = dtype;
        version_ = version;
        vendorName_ = vendorName;
        vendorData_ = vendorData;
    }

    // get all contract data
    function get() public alwaysAccept view returns (
        address node,
        address elector,
        address vendor,
        string[] owners,
        bool active,
        bool lock,
        bool stat,
        string dtype,
        string version,
        string vendorName,
        string vendorData,
        uint32 lastRegisterTime
    ) {
        return (
            node_,
            elector_,
            vendor_,
            owners_,
            active_,
            lock_,
            stat_,
            dtype_,
            version_,
            vendorName_,
            vendorData_,
            lastRegisterTime_
        );
    }

    // Send update event to node  
    function _sendUpdate() private view {
        tvm.accept();
        INode(node_).deviceUpdate(address(this));
    }

    // Set current node address for device
    function setNode(address node) public onlyDevice {
        // check if node address is not empty
        require(node != address(0), Errors.EMPTY_ADDRESS);

        INode(node).deviceRegister(address(this), node_);

        //TvmCell message = tvm.encodeBody(INode.deviceRegister, address(this), node_);
        //node.transfer(0, false, 3, message);

        // set new node address
        node_ = node;
        // update last register time
        lastRegisterTime_ = block.timestamp;
    
    }


    // Get current node address for device
    function getNode() public alwaysAccept view returns (address) {
        return node_;
    }

    // Get elector address for device
    function getElector() public alwaysAccept view returns (address) {
        return elector_;
    }

    // Get vendor address for device
    function getVendor() public alwaysAccept view returns (address) {
        return vendor_;
    }

    function getVendorData() public onlyVendorContract view returns (string) {
        return vendorData_;
    }

    // Get public keys of device owners
    function getOwners() public alwaysAccept view returns (string[]) {
        return owners_;
    }

    // Add owner public key
    function addOwner(string owner) public onlyOwner {
        if (!isOwnerExists(owner)) {
            owners_.push(owner);
        }
         _sendUpdate();
    }

    // Check if the owner already exists
    function isOwnerExists(string owner) private view returns (bool) {
        for (uint i = 0; i < owners_.length; i++) {
            if (owners_[i] == owner) {
                return true;
            }
        }
        return false;
    }

    // Removes owner by value from owners list
    function removeOwner(string owner) public onlyOwner {
        for (uint i = 0; i < owners_.length; i++) {
            if (owners_[i] == owner) {
                _removeOwner(i);
                break;
            }
        }
         _sendUpdate();
    }

    // Removes element by index from owners_ array
    function _removeOwner(uint index) private {
        // overwrite index element with last element
        owners_[index] = owners_[owners_.length - 1];
        // remove last element
        owners_.pop();
    }

    // Get contract version
    function v() public alwaysAccept view returns (uint32 contractVersion) {
        return contractVersion_;
    }

    // lock / unlock device
    function setLock(bool lock) public onlyOwner {
        lock_ = lock;
         _sendUpdate();
    }

    // set device active / inactive
    function setActive(bool active) public onlyOwner {
        active_ = active;
         _sendUpdate();
    }

    // enable / disable collecting stat
    function setStat(bool stat) public onlyOwner {
        stat_ = stat;
         _sendUpdate();
    }

    function getLastRegisterTime() public alwaysAccept view returns (uint32) {
        return lastRegisterTime_;
    }

    // Upgrade contract code
    function upgrade(TvmCell code) external override alwaysAccept {
        tvm.setcode(code);
        tvm.setCurrentCode(code);

        TvmCell data = abi.encode(
            node_,
            elector_,
            vendor_,
            owners_,
            active_,
            lock_,
            stat_,
            dtype_,
            version_,
            vendorName_,
            vendorData_,
            lastRegisterTime_);

        onCodeUpgrade(data);
    }

    function onCodeUpgrade(TvmCell data) private {
//        tvm.resetStorage(); // when new state var is added

        (node_,
        elector_,
        vendor_,
        owners_,
        active_,
        lock_,
        stat_,
        dtype_,
        version_,
        vendorName_,
        vendorData_,
        lastRegisterTime_) = abi.decode(data,
            (address,
            address,
            address,
            string[],
            bool,
            bool,
            bool,
            string,
            string,
            string,
            string,
            uint32)
        );

        ++contractVersion_;
    }
}
