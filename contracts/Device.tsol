pragma ever-solidity ^0.70.0;

pragma AbiHeader expire;
pragma AbiHeader pubkey;

import {IUpgradable} from "./interfaces/IUpgradable.tsol";
import {Errors} from "./libraries/Errors.tsol";
import {INode} from "./interfaces/INode.tsol";
import {DeviceGroup} from "./DeviceGroup.tsol";
import {Elector} from "./Elector.tsol";

contract Device is IUpgradable {
    string name_; // device name
    mapping(uint256 => address) owners_; // device owners: public_key => contract_address(if exists)
    string dtype_; // device type
    string version_; // firmware version
    uint32 lastRegisterTime_; // last registration timestamp

    address group_; // address of DeviceGroup contract that device belongs to

    address node_; // current node address

    address elector_; // elector contract address

    address deviceAPI_; // device API contract address

    address vendor_; // vendor contract address
    string vendorName_; // readable name of vendor
    string vendorData_; // vendor data

    bool lock_; // device lock / unlock for management
    bool stat_; // enable / disable collecting stat
    bool events_; // enable / disable sending events

    //events

    // Event that is emitted when node address is changed
    event NodeChange(address indexed contractAddress, address oldNode, address newNode);

    // Event that is emitted when some device data was changed
    event DeviceUpdate(address indexed contractAddress, address newNode);

    // Custom event
    event DeviceEvent(string name, string data);

    function deviceEvent(string name, string data) public view onlyOwner {
        emit DeviceEvent(name, data);
        DeviceGroup(group_).groupEvent(name, data);
    }


    // Modifier that allows public function to accept all external calls.
    modifier alwaysAccept {
        tvm.accept();
        _ensureGas();
        _;
    }

    modifier onlyDevice() {
        require(msg.pubkey() == tvm.pubkey(), Errors.NOT_ALLOWED);
        tvm.accept();
        _ensureGas();
        _;
    }

    modifier onlyOwner() {
        require(msg.pubkey() == tvm.pubkey() || owners_.exists(msg.pubkey()), Errors.NOT_ALLOWED);
        tvm.accept();
        _ensureGas();
        _;
    }

    modifier onlyElectorContract() {
        require(msg.sender == elector_, Errors.NOT_ALLOWED);
        tvm.accept();
        _ensureGas();
        _;
    }

    modifier onlyNodeContract() {
        require(msg.sender == node_, Errors.NOT_ALLOWED);
        tvm.accept();
        _ensureGas();
        _;
    }

    modifier onlyVendorContract() {
        require(msg.sender == vendor_, Errors.NOT_ALLOWED);
        tvm.accept();
        _ensureGas();
        _;
    }

    constructor(
        string name,
        address elector,
        address vendor,
        address group,
        address deviceAPI,
        mapping(uint256 => address) owners,
        string dtype,
        string version,
        string vendorName,
        string vendorData,
        bool stat,
        bool events
    ) {
        tvm.accept();
        tvm.resetStorage();
        // setup contract data
        name_ = name;
        elector_ = elector;
        vendor_ = vendor;
        group_ = group;
        deviceAPI_ = deviceAPI;
        owners_ = owners;
        dtype_ = dtype;
        version_ = version;
        vendorName_ = vendorName;
        vendorData_ = vendorData;
        stat_ = stat;
        events_ = events;
    }

    // get tokens for gas from device group if needed
    function _ensureGas() private view {
        if (address(this).balance < 0.5 ever) {
            require(group_ != address(0), Errors.EMPTY_GROUP);
            DeviceGroup(group_).transfer(address(this), 1 ever);
        }
    }

    // Send update event to node
    function _sendUpdate() private view {
        INode(node_).deviceUpdate(address(this));
    }

    // Set current node address for device
    function setNode(address node) public onlyDevice {
        // check if node address is not empty
        require(node != address(0), Errors.EMPTY_ADDRESS);

        Elector(elector_).getPayment(group_);

        INode(node).deviceRegister(address(this), node_);

        //TvmCell message = tvm.encodeBody(INode.deviceRegister, address(this), node_);
        //node.transfer(0, false, 3, message);

        emit NodeChange(address(this), node_, node);

        // set new node address
        node_ = node;
        // update last register time
        lastRegisterTime_ = block.timestamp;
    }

    // Add owner public key and contract address if any
    function addOwner(uint256 pubKey, address addr) public onlyOwner {
        owners_[pubKey] = addr;
        _sendUpdate();
    }

    // Remove owner data by public key from owners list
    function removeOwner(uint256 pubKey) public onlyOwner {
        delete owners_[pubKey];
        _sendUpdate();
    }

    // Set device name
    function setName(string name) public onlyOwner {
        name_ = name;
        _sendUpdate();
    }

    // lock / unlock device
    function setLock(bool lock) public onlyOwner {
        lock_ = lock;
        _sendUpdate();
    }

    // enable / disable collecting stat
    function setStat(bool stat) public onlyOwner {
        stat_ = stat;
        _sendUpdate();
    }

    // enable / disable sending events
    function setEvents(bool events) public onlyOwner {
        events_ = events;
        _sendUpdate();
    }

    // set device group contract address
    function setGroup(address group) public onlyOwner {
        group_ = group;
        _sendUpdate();
    }

    // set device API contract address
    function setDeviceAPI(address deviceAPI) public onlyOwner {
        deviceAPI_ = deviceAPI;
        _sendUpdate();
    }

    // set vendor contract address
    function setVendor(address vendor) public onlyOwner {
        vendor_ = vendor;
        _sendUpdate();
    }

    // send tokens to dest address
    function sendTransaction(address dest, uint128 value) public onlyOwner view {
        dest.transfer(value, true, 3);
    }

    // Upgrade contract code
    function upgrade(TvmCell code) external override alwaysAccept {
        tvm.setcode(code);
        tvm.setCurrentCode(code);

        TvmCell data = abi.encode(
            name_,
            node_,
            elector_,
            vendor_,
            group_,
            deviceAPI_,
            owners_,
            lock_,
            stat_,
            events_,
            dtype_,
            version_,
            vendorName_,
            vendorData_,
            lastRegisterTime_);

        onCodeUpgrade(data);
    }

    function onCodeUpgrade(TvmCell data) private {
//        tvm.resetStorage();
//
//        (name_,
//        node_,
//        elector_,
//        vendor_,
//        group_,
//        owners_,
//        lock_,
//        stat_,
//        events_,
//        dtype_,
//        version_,
//        vendorName_,
//        vendorData_,
//        lastRegisterTime_) = abi.decode(data,
//            (string,
//            address,
//            address,
//            address,
//            address,
//            mapping(uint256 => address),
//            bool,
//            bool,
//            bool,
//            string,
//            string,
//            string,
//            string,
//            uint32)
//        );
    }
}
