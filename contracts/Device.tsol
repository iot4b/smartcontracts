pragma ever-solidity ^0.71.0;

pragma AbiHeader expire;

import {IUpgradable} from "./interfaces/IUpgradable.tsol";

contract Device is IUpgradable {
    uint32 contractVersion_;

    address public node_;
    address public elector_;
    address public vendor_;

    string[] public owners_; // public keys of device owners

    bool public active_;
    bool public lock_;
    bool public stat_;

    string public dtype_;
    string public version_;
    string public vendorName_;
    string public vendorData_;

    uint32 public lastRegisterTime_; // last registration timestamp

    // Modifier that allows public function to accept all external calls.
    modifier alwaysAccept {
        tvm.accept();
        _;
    }

    modifier onlyElectorContract() {
        require(msg.sender == elector_, 102);
        tvm.accept();
        _;
    }

    modifier onlyNodeContract() {
        require(msg.sender == node_, 102);
        tvm.accept();
        _;
    }

    modifier onlyVendorContract() {
        require(msg.sender == vendor_, 102);
        tvm.accept();
        _;
    }

    constructor(
        address elector,
        address vendor,

        string[] owners,

        string dtype,
        string version,
        string vendorName,
        string vendorData
    ) {
        tvm.accept();
        // setup addresses data
        elector_ = elector;
        vendor_ = vendor;

        owners_ = owners;

        active_ = false;
        lock_ = false;
        stat_ = false;

        dtype_ = dtype;
        version_ = version;
        vendorName_ = vendorName;
        vendorData_ = vendorData;
    }

    // get all contract data
    function get() public alwaysAccept view returns (
        address node,
        address elector,
        address vendor,
        string[] owners,
        bool active,
        bool lock,
        bool stat,
        string dtype,
        string version,
        string vendorName,
        string vendorData,
        uint32 lastRegisterTime
    ) {
        return (
            node_,
            elector_,
            vendor_,
            owners_,
            active_,
            lock_,
            stat_,
            dtype_,
            version_,
            vendorName_,
            vendorData_,
            lastRegisterTime_
        );
    }

    // Set current node address for device
    function setNode(address value) public alwaysAccept {
        node_ = value;
        lastRegisterTime_ = block.timestamp;
    }

    // Get current node address for device
    function getNode() public alwaysAccept view returns (address) {
        return node_;
    }

    // Get elector address for device
    function getElector() public alwaysAccept view returns (address) {
        return elector_;
    }

    // Get vendor address for device
    function getVendor() public alwaysAccept view returns (address) {
        return vendor_;
    }

    function getVendorData() public onlyVendorContract view returns (string) {
        return vendorData_;
    }

    // Get public keys of device owners
    function getOwners() public alwaysAccept view returns (string[]) {
        return owners_;
    }

    // Add owner public key
    function addOwner(string owner) public alwaysAccept {
        if (!isOwnerExists(owner)) {
            owners_.push(owner);
        }
    }

    // Check if the owner already exists
    function isOwnerExists(string owner) private view returns (bool) {
        for (uint i = 0; i < owners_.length; i++) {
            if (owners_[i] == owner) {
                return true;
            }
        }
        return false;
    }

    // Removes owner by value from owners list
    function removeOwner(string owner) public alwaysAccept {
        for (uint i = 0; i < owners_.length; i++) {
            if (owners_[i] == owner) {
                removeOwner(i);
                break;
            }
        }
    }

    // Removes element by index from owners_ array
    function removeOwner(uint index) private {
        // overwrite index element with last element
        owners_[index] = owners_[owners_.length - 1];
        // remove last element
        owners_.pop();
    }

    // Get contract version
    function v() public alwaysAccept view returns (uint32 contractVersion) {
        return contractVersion_;
    }

    // lock / unlock device
    function setLock(bool lock) public alwaysAccept {
        lock_ = lock;
    }

    // set device active / inactive
    function setActive(bool active) public alwaysAccept {
        active_ = active;
    }

    // enable / disable collecting stat
    function setStat(bool stat) public alwaysAccept {
        stat_ = stat;
    }

    function getLastRegisterTime() public alwaysAccept view returns (uint32) {
        return lastRegisterTime_;
    }

    // Upgrade contract code
    function upgrade(TvmCell code) external override alwaysAccept {
        tvm.setcode(code);
        tvm.setCurrentCode(code);

        TvmCell data = abi.encode(
            node_,
            elector_,
            vendor_,
            owners_,
            active_,
            lock_,
            stat_,
            dtype_,
            version_,
            vendorName_,
            vendorData_,
            lastRegisterTime_);

        onCodeUpgrade(data);
    }

    function onCodeUpgrade(TvmCell data) private {
//        tvm.resetStorage(); // when new state var is added

        (node_,
        elector_,
        vendor_,
        owners_,
        active_,
        lock_,
        stat_,
        dtype_,
        version_,
        vendorName_,
        vendorData_,
        lastRegisterTime_) = abi.decode(data,
            (address,
            address,
            address,
            string[],
            bool,
            bool,
            bool,
            string,
            string,
            string,
            string,
            uint32)
        );

        ++contractVersion_;
    }
}
