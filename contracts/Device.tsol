pragma ever-solidity ^0.71.0;

pragma AbiHeader expire;

import {IUpgradable} from "./interfaces/IUpgradable.tsol";
import {Errors} from "./libraries/Errors.tsol";

contract Device is IUpgradable {
    uint32 contractVersion_; // contract version

    string[] public owners_; // public keys of device owners
    string public dtype_; // device type 
    string public version_; // firmware version

    address public node_; // current node address
    uint32 public lastRegisterTime_; // last registration timestamp

    address public elector_; // elector contract address

    address public vendor_; // vendor contract address
    string public vendorName_; // readable name of vendor
    string public vendorData_; // vendor data

    bool public active_; // device active / inactive for iot4b services
    bool public lock_; // device lock / unlock for management
    bool public stat_; // enable / disable collecting stat

    //events
    
    // Event that is emitted when node address is changed
    event NodeChange(address indexed contractAddress, address oldNode, address newNode);

    // Event that is emitted when some device data was changed
    event DeviceUpdate(address indexed contractAddress, address newNode);


    // Modifier that allows public function to accept all external calls.
    modifier alwaysAccept {
        tvm.accept();
        _;
    }

    modifier onlyDevice() {
        require(msg.pubkey() == tvm.pubkey(), Errors.NOT_ALLOWED);
        tvm.accept();
        _;
    }

    modifier onlyElectorContract() {
        require(msg.sender == elector_, Errors.NOT_ALLOWED);
        tvm.accept();
        _;
    }

    modifier onlyNodeContract() {
        require(msg.sender == node_, Errors.NOT_ALLOWED);
        tvm.accept();
        _;
    }

    modifier onlyVendorContract() {
        require(msg.sender == vendor_, Errors.NOT_ALLOWED);
        tvm.accept();
        _;
    }

    constructor(
        address elector,
        address vendor,
        string[] owners,
        string dtype,
        string version,
        string vendorName,
        string vendorData
    ) {
        tvm.accept();
        // setup addresses data
        elector_ = elector;
        vendor_ = vendor;
        owners_ = owners;
        active_ = false;
        lock_ = false;
        stat_ = false;
        dtype_ = dtype;
        version_ = version;
        vendorName_ = vendorName;
        vendorData_ = vendorData;
    }

    // get all contract data
    function get() public alwaysAccept view returns (
        address node,
        address elector,
        address vendor,
        string[] owners,
        bool active,
        bool lock,
        bool stat,
        string dtype,
        string version,
        string vendorName,
        string vendorData,
        uint32 lastRegisterTime
    ) {
        return (
            node_,
            elector_,
            vendor_,
            owners_,
            active_,
            lock_,
            stat_,
            dtype_,
            version_,
            vendorName_,
            vendorData_,
            lastRegisterTime_
        );
    }


    // Set current node address for device
    function setNode(address node) public onlyDevice {
        tvm.accept();
        // check if node address is not empty
        require(node != address(0), Errors.EMPTY_ADDRESS);

        // Формирование исходящего сообщения
        TvmBuilder builder;
        builder.store(address(this));
        builder.store(node_);
        builder.store(node);
        TvmCell payload = builder.toCell();
        
        // Формирование сообщения
        /* 
        TvmCell message = tvm.buildExtMsg({
            dest: node,
            time:uint64,
            expire:uint64,
            call:{functionIdentifier[, list_of_function_arguments]},
            sign:bool,
            pubkey:optional(uint256),
            callbackId:uint32,
            onErrorId:uint32,
            stateInit:TvmCell,
            signBoxHandle:optional(uint32)
            });
        */
        TvmCell message = tvm.buildExtMsg({
            dest: node,      // Адрес получателя
            value: 0,        // Количество токенов для отправки
            bounce: false,        // Отключение возврата сообщения при неудаче
            stateInit: payload,         // Payload 
            sign: true,          // Требуется подпись отправителя  
            pubkey: tvm.pubkey() // Публичный ключ отправителя
        });

        // Отправка сообщения
        tvm.sendrawmsg(message, 0); // Флаг 0 для отправки без bounce

        // set new node address
        node_ = node;
        // update last register time
        lastRegisterTime_ = block.timestamp;
    
    }


    // Get current node address for device
    function getNode() public alwaysAccept view returns (address) {
        return node_;
    }

    // Get elector address for device
    function getElector() public alwaysAccept view returns (address) {
        return elector_;
    }

    // Get vendor address for device
    function getVendor() public alwaysAccept view returns (address) {
        return vendor_;
    }

    function getVendorData() public onlyVendorContract view returns (string) {
        return vendorData_;
    }

    // Get public keys of device owners
    function getOwners() public alwaysAccept view returns (string[]) {
        return owners_;
    }

    // Add owner public key
    function addOwner(string owner) public onlyDevice {
        if (!isOwnerExists(owner)) {
            owners_.push(owner);
        }
    }

    // Check if the owner already exists
    function isOwnerExists(string owner) private view returns (bool) {
        for (uint i = 0; i < owners_.length; i++) {
            if (owners_[i] == owner) {
                return true;
            }
        }
        return false;
    }

    // Removes owner by value from owners list
    function removeOwner(string owner) public onlyDevice {
        for (uint i = 0; i < owners_.length; i++) {
            if (owners_[i] == owner) {
                _removeOwner(i);
                break;
            }
        }
    }

    // Removes element by index from owners_ array
    function _removeOwner(uint index) private {
        // overwrite index element with last element
        owners_[index] = owners_[owners_.length - 1];
        // remove last element
        owners_.pop();
    }

    // Get contract version
    function v() public alwaysAccept view returns (uint32 contractVersion) {
        return contractVersion_;
    }

    // lock / unlock device
    function setLock(bool lock) public onlyDevice {  //TODO переписать на onlyOwner
        lock_ = lock;
    }

    // set device active / inactive
    function setActive(bool active) public onlyDevice { //TODO переписать на onlyOwner
        active_ = active;
    }

    // enable / disable collecting stat
    function setStat(bool stat) public onlyDevice { //TODO переписать на onlyOwner
        stat_ = stat;
    }

    function getLastRegisterTime() public alwaysAccept view returns (uint32) {
        return lastRegisterTime_;
    }

    // Upgrade contract code
    function upgrade(TvmCell code) external override onlyDevice {
        tvm.setcode(code);
        tvm.setCurrentCode(code);

        TvmCell data = abi.encode(
            node_,
            elector_,
            vendor_,
            owners_,
            active_,
            lock_,
            stat_,
            dtype_,
            version_,
            vendorName_,
            vendorData_,
            lastRegisterTime_);

        onCodeUpgrade(data);
    }

    function onCodeUpgrade(TvmCell data) private {
//        tvm.resetStorage(); // when new state var is added

        (node_,
        elector_,
        vendor_,
        owners_,
        active_,
        lock_,
        stat_,
        dtype_,
        version_,
        vendorName_,
        vendorData_,
        lastRegisterTime_) = abi.decode(data,
            (address,
            address,
            address,
            string[],
            bool,
            bool,
            bool,
            string,
            string,
            string,
            string,
            uint32)
        );

        ++contractVersion_;
    }
}
