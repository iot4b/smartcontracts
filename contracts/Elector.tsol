pragma ever-solidity ^0.70.0;

pragma AbiHeader expire;
pragma AbiHeader pubkey;

import {IUpgradable} from "./interfaces/IUpgradable.tsol";
import {Errors} from "./libraries/Errors.tsol";
import {DeviceGroup} from "./DeviceGroup.tsol";

contract Elector is IUpgradable {
    mapping(address => bool) public nodesCurrent_; // List of current nodes
    mapping(address => bool) public nodesNext_; // List of next nodes
    mapping(address => bool) public nodesParticipants_; // List of all nodes that want to participate in the election
    mapping(address => uint) public nodesFault_; // list of nodes who was fault in current round

    modifier onlyOwner {
        require(msg.pubkey() == tvm.pubkey(), Errors.NOT_ALLOWED);
        tvm.accept();
        _;
    }

    constructor(
        mapping(address => bool) defaultNodes
    ) {
        tvm.accept();
        nodesCurrent_ = defaultNodes;
    }

    function get() public view returns (
        mapping(address => bool) nodesCurrent,
        mapping(address => bool) nodesNext,
        mapping(address => bool) nodesParticipants,
        mapping(address => uint) nodesFault
    )  {
        return (
            nodesCurrent_,
            nodesNext_,
            nodesParticipants_,
            nodesFault_
        );
    }

    // Get tokens from DeviceGroup
    function getPayment(address group) external pure {
        DeviceGroup(group).transferToElector(1 ever);
    }

    // Transfer tokens to dest address
    function transfer(address dest, uint128 value) external view onlyOwner {
        dest.transfer(value);
    }

    // Set current period nodes
    function setNodes(mapping(address => bool) _nodes) external onlyOwner {
        nodesCurrent_ = _nodes;
    }

    // Add node to next round
    function takeNextRound(address _address) external onlyOwner {
        nodesParticipants_[_address] = true;
    }

    // Increase fault node counter. If counter >= 5 then remove node from current list.
    function reportFaultNode(address _address) external onlyOwner {
        ++nodesFault_[_address];
        if (nodesFault_[_address] >= 5) {
            delete nodesCurrent_[_address];
            delete nodesFault_[_address];
        }
    }

    // Make election for next round
    function election() external onlyOwner {
        // loop over participants
        address[] arrParticipants = nodesParticipants_.keys();
        for (uint i = 0; i < arrParticipants.length; i++) {
            // add participant to current list if not exists
            nodesCurrent_[arrParticipants[i]] = true;
        }
        // clear participant list
        delete nodesParticipants_;
    }


    /*
    v1
    func CurrentList() // список текущих нод на этом раунде
    func TakeNextRound(node-address) //принять участие в следующем раунде 
    func Election() // провести выборы для следующего раунда
    func ReportFaultNode(node-address) // сообщить о некорректной работе ноды


    v2
    func NextList()  // список нод на следующем электоре
    func Participants() // список всех нод желающих участвовать в электоре

    v3
    func ProcessPaymentsNode(node-address) // обработать выплаты ноде
    func ProcessPaymentsVendor(vendor-address) // обработать выплаты вендору
    func Deposit() // пополнить депозит для девайса
    func WithdrawDeposit(device-address) // вывести депозит для девайса



    */

    // Upgrade contract code
    function upgrade(TvmCell code) external override onlyOwner {
        TvmCell data = abi.encode(
            nodesCurrent_,
            nodesNext_,
            nodesParticipants_,
            nodesFault_);

        tvm.setcode(code);
        tvm.setCurrentCode(code);

        onCodeUpgrade(data);
    }

    function onCodeUpgrade(TvmCell data) private {
        (nodesCurrent_,
        nodesNext_,
        nodesParticipants_,
        nodesFault_) = abi.decode(data,
            (mapping(address => bool),
            mapping(address => bool),
            mapping(address => bool),
            mapping(address => uint))
        );
    }
}
