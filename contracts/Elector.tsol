pragma ever-solidity ^0.70.0;

pragma AbiHeader expire;

import {IUpgradable} from "./interfaces/IUpgradable.tsol";
import {Errors} from "./libraries/Errors.tsol";
import {DeviceGroup} from "./DeviceGroup.tsol";

contract Elector is IUpgradable {
    address[] public nodesCurrent_; // List of current nodes
    address[] public nodesNext_; // List of next nodes
    address[] public nodesParticipants_; // List of all nodes that want to participate in the election
    mapping(address => uint) public nodesFault_; // list of nodes who was fault in current round


    // Modifier that allows public function to accept all external calls.
    modifier alwaysAccept {
        tvm.accept();
        _;
    }

    modifier onlyOwner {
        require(msg.pubkey() == tvm.pubkey(), Errors.NOT_ALLOWED);
        tvm.accept();
        _;
    }

    constructor(
        address[] defaultNodes
    ) {
        tvm.accept();
        nodesCurrent_ = defaultNodes;
    }

    // Get tokens from DeviceGroup
    function getPayment(address group) public pure alwaysAccept {
        DeviceGroup(group).transferToElector(1_000_000_000);
    }

    // Transfer tokens to dest address
    function transfer(address dest, uint128 value) public view onlyOwner {
        dest.transfer(value);
    }

    // Set current period nodes
    function setNodes(address[] _nodes) public alwaysAccept {
        nodesCurrent_ = _nodes;
    }

    // Return current period nodes
    function currentList() public alwaysAccept view returns (address[] nodes) {
        return nodesCurrent_;
    }

    // Return next period participants
    function participantList() public alwaysAccept view returns (address[] participants) {
        return nodesParticipants_;
    }

    // Add node to next round
    function takeNextRound(address _address) public alwaysAccept {
        int i = arrayIndex(_address, nodesParticipants_);
        if (i == -1) {
            nodesParticipants_.push(_address);
        }
    }

    // Increase fault node counter. If counter >= 5 then remove node from current list.
    function reportFaultNode(address _address) public alwaysAccept {
        ++nodesFault_[_address];
        if (nodesFault_[_address] >= 5) {
            kickNode(_address);
            delete nodesFault_[_address];
        }
    }

    // Make election for next round
    function election() public alwaysAccept {
        // loop over participants
        for (uint i = 0; i < nodesParticipants_.length; i++) {
            int j = arrayIndex(nodesParticipants_[i], nodesCurrent_);
            if (j == -1) {
                // add participant to current list if not exists
                nodesCurrent_.push(nodesParticipants_[i]);
            }
        }
        // clear participant list
        delete nodesParticipants_;
    }

    // Removes node by address from current period list
    function kickNode(address _address) private {
        int i = arrayIndex(_address, nodesCurrent_);
        if (i >= 0) {
            removeCurrent(i);
        }
    }

    // Removes element by index from nodesCurrent_ array
    function removeCurrent(int index) private {
        // overwrite index element with last element
        nodesCurrent_[uint(index)] = nodesCurrent_[nodesCurrent_.length - 1];
        // remove last element
        nodesCurrent_.pop();
    }

    // Check if address value exists in array
    // returns array index if exists, -1 otherwise
    function arrayIndex(address value, address[] array) private pure returns (int) {
        for (uint i = 0; i < array.length; i++) {
            if (array[i] == value) {
                return int(i);
            }
        }
        return -1;
    }


    /*
    v1
    func CurrentList() // список текущих нод на этом раунде
    func TakeNextRound(node-address) //принять участие в следующем раунде 
    func Election() // провести выборы для следующего раунда
    func ReportFaultNode(node-address) // сообщить о некорректной работе ноды


    v2
    func NextList()  // список нод на следующем электоре
    func Participants() // список всех нод желающих участвовать в электоре

    v3
    func ProcessPaymentsNode(node-address) // обработать выплаты ноде
    func ProcessPaymentsVendor(vendor-address) // обработать выплаты вендору
    func Deposit() // пополнить депозит для девайса
    func WithdrawDeposit(device-address) // вывести депозит для девайса



    */

    // Upgrade contract code
    function upgrade(TvmCell code) external override alwaysAccept {
        tvm.setcode(code);
        tvm.setCurrentCode(code);

        TvmCell data = abi.encode(
            nodesCurrent_,
            nodesNext_,
            nodesParticipants_,
            nodesFault_);

        onCodeUpgrade(data);
    }

    function onCodeUpgrade(TvmCell data) private {
        (nodesCurrent_,
        nodesNext_,
        nodesParticipants_,
        nodesFault_) = abi.decode(data,
            (address[],
            address[],
            address[],
            mapping(address => uint))
        );
    }
}
